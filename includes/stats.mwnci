include(
    "math"
)

if (!INCLUDE["STATS"]) {
    INCLUDE=set(INCLUDE, "STATS", true)

    function covariance(X, Y, Type="s") {
        if (!checkfunctype("covariance", "array", X, 1)) {exit(1)}
        if (!checkfunctype("covariance", "array", Y, 2)) {exit(1)}
        if (!checkfunctype("covariance", "string", Type, 3)) {exit(1)}
        Type=tolower(Type)
        CVType=Type
        if (len(Type) > 1) {
            println("Error calling `covariance`: ERROR: StringError: covariance() takes a single character `s` or `p` for the 2nd argument")
        }
        LenX=len(X)
        LenY=len(Y)
        if (LenX != LenY) {
            println("Error calling `covariance`: ERROR: StatisticsError: Data sets must be of the same length ")
            exit(1)
        }
        MeanX=mean(X)
        MeanY=mean(Y)
        if (CVType == "p") {
            Obs=LenX
            Range=Obs-1
        } else {
            Obs=LenX-1
            Range=Obs
        }
        Counter=0
        foreach Index in 0..Range {
            Counter += (X[Index]-MeanX) * (Y[Index]-MeanY)
        }
        return  Counter / Obs
    }

    function variance(MyArray, Type="s") {
        if (!checkfunctype("variance", "array", MyArray, 1)) {exit(1)}
        if (!checkfunctype("variance", "string", Type, 2)) {exit(1)}
        if (len(MyArray) < 2) {
            println("Error calling `variance`: ERROR: StatisticsError: Data set has fewer than 2 values")
            exit(1)
        }
        Type=tolower(Type)
        if (len(Type) > 1) {
            println("Error calling `variance`: ERROR: StringError: variance() takes a single character `s` or `p` for the 2nd argument")
            exit(1)
        }
        Pop=len(MyArray)
        Samp=Pop-1
        DivNum = (tolower(Type) == "s") ? Samp : Pop
        Mean=mean(MyArray)
        VarCount=0
        foreach Num in MyArray {
            VarNum=abs(Num - Mean) ** 2
            VarCount += VarNum
        }
        return VarCount / DivNum
    }

    function stdev(MyArray, Type="s") {
        if (!checkfunctype("stdev", "array", MyArray, 1)) {exit(1)}
        if (!checkfunctype("stdev", "string", Type, 2)) {exit(1)}
        if (len(MyArray) < 2) {
            println("Error calling `stdev`: ERROR: StatisticsError: Data has fewer than 2 values")
            exit(1)
        }
        if (len(Type) > 1) {
            println("Error calling `stdev`: ERROR: StringError: stdev() takes a single character `s` or `p` for the 2nd argument")
            exit(1)
        }
        return sqrt(variance(MyArray, Type))
    }

    function mode(MyArray) {
        if (!checkfunctype("mode", "array", MyArray, 1)) {exit(1)}
        if (len(MyArray) == 0) {
            println("Error calling `mode`: ERROR: StatisticsError: No data")
            exit(1)
        }
        ModeArray=[]
        UniqCount=ucount(MyArray)
        Highest=reverse(usort(values(UniqCount)))[0]
        foreach Key in keys(UniqCount) {
            if (UniqCount[Key] == Highest) {
                ModeArray=push(ModeArray, Key)
            }
        }
        return (len(ModeArray) == 1) ? ModeArray[0] : ModeArray
    }

    function average(MyArray=[]) {
        if (!checkfunctype("average", "array", MyArray, 1)) {exit(1)}
        if (len(MyArray) == 0) {
            println("Error calling `average`: ERROR: StatisticsError: No data")
            exit(1)
        }
        return float(sum(MyArray) / float(len(MyArray)))
    }

    //
    // For the mathematical pedants ;)
    //

    function mean(ave_array=[]) {
        if (!checkfunctype("mean", "array", ave_array, 1)) {exit(1)}
        if (len(ave_array) == 0) {
            println("Error calling `mean`: ERROR: StatisticsError: No data")
            exit(1)
        }
        return average(ave_array)
    }

    // End pedantry

    function median(MedianArray=[]) {
        if (!checkfunctype("median", "array", MedianArray)) {exit(1)}
        if (len(MedianArray) == 0) {
            println("Error calling `median`: ERROR: StatisticsError: No data")
            exit(1)
        }        
        NewArray=float(MedianArray)
        MedianArray=copy(NewArray)
        MedianArray=sort(MedianArray)
        Len=len(MedianArray)
        Calc=divmod(Len, 2)
        Pos=Calc[0]
        Remainder=Calc[1]
        if (Remainder == 1) {
            Median=MedianArray[Pos]
        } else {
            Median=(float(MedianArray[Pos]) + float(MedianArray[Pos-1]))/2.0
        }
        return Median
    }
    
    function harmonicmean(MyArray=[]) {
        if (!checkfunctype("harmonicmean", "array", MyArray)) {exit(1)}
        if (len(MyArray) == 0) {
            println("Error calling `harmonicmean`: ERROR: StatisticsError: No data")
            exit(1)
        }              
        Obs=len(MyArray)
        Counter=0
        foreach n in MyArray {
            Counter += (1/float(n))
        }
        return Obs / Counter
    }

    function geomean(Array=[]) {
        if (!checkfunctype("geomean", "array", Array, 1)) {exit(1)}
        N=len(Array)
        if (N == 0) {
            println("Error calling `geomean`: ERROR: StatisticsError: No data")
            exit(1)
        }
        return pow(product(Array), (1.0/N))
    }
    
    function array.mode() {
        return mode(self)
    }

    function array.average() {
        return average(self)
    }

    function array.mean() {
        return mean(self)
    }

    function array.median() {
        return median(self)
    }

    function array.harmonicmean() {
        return harmonicmean(self)
    }

    function array.geomean() {
        return geomean(self)
    }
}

