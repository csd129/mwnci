if (!INCLUDE["STATS"]) {
    INCLUDE=set(INCLUDE, "STATS", true)

    function cov(X, Y, Type="s") {
        if (!checkfunctype("cov", "array", X, 1)) {exit(1)}
        if (!checkfunctype("cov", "array", Y, 2)) {exit(1)}
        if (!checkfunctype("cov", "string", Type, 3)) {exit(1)}
        Type=tolower(Type)
        if (len(Type) > 1) {
            println("Error calling `cov`: ERROR: StringError: cov() takes a single character `s` or `p` for the 2nd argument")
        }
        LenX=len(X)
        LenY=len(Y)
        if (LenX != LenY) {
            println("Error: `cov` requires arrays of equal length.")
            exit(1)
        }
        MeanX=mean(X)
        MeanY=mean(Y)
        if (Type == "p") {
            Obs=LenX
            Range=Obs-1
        } else {
            Obs=LenX-1
            Range=Obs
        }
        Counter=0
        foreach Index in 0..Range {
            Counter += (X[Index]-MeanX) * (Y[Index]-MeanY)
        }
        return  Counter / Obs
    }

    function variance(MyArray, Type="s") {
        if (!checkfunctype("variance", "array", MyArray, 1)) {exit(1)}
        if (!checkfunctype("variance", "string", Type, 2)) {exit(1)}
        Type=tolower(Type)
        if (len(Type) > 1) {
            println("Error calling `variance`: ERROR: StringError: variance() takes a single character `s` or `p` for the 2nd argument")
            exit(1)
        }
        Pop=len(MyArray)
        Samp=Pop-1
        DivNum = (tolower(Type) == "s") ? Samp : Pop
        Mean=mean(MyArray)
        VarCount=0
        foreach Num in MyArray {
            VarNum=abs(Num - Mean) ** 2
            VarCount += VarNum
        }
        return VarCount / DivNum
    }

    function stdev(MyArray, Type="s") {
        if (!checkfunctype("stdev", "array", MyArray, 1)) {exit(1)}
        if (!checkfunctype("stdev", "string", Type, 2)) {exit(1)}
        if (len(Type) > 1) {
            println("Error calling `stdev`: ERROR: StringError: stdev() takes a single character `s` or `p` for the 2nd argument")
            exit(1)
        }
        return sqrt(variance(MyArray, Type))
    }

    function mode(MyArray) {
        if (!checkfunctype("mode", "array", MyArray, 1)) {exit(1)}
        UniqCount=ucount(MyArray)
        Largest=0
        Numbers=""
        foreach Amount in keys(UniqCount) {
            if (UniqCount[Amount] > Largest) {
                Numbers=Amount
                Largest=UniqCount[Amount]
            } else {
                if (UniqCount[Amount] == Largest) {
                    Numbers=Numbers + " " + Amount
                }
            }
        }
        return float(sort(fields(Numbers)))
    }

    function average(MyArray) {
        if (!checkfunctype("average", "array", MyArray, 1)) {exit(1)}
        return float(sum(MyArray) / float(len(MyArray)))
    }

    //
    // For the mathematical pedants ;)
    //

    function mean(ave_array) {
        if (!checkfunctype("mean", "array", ave_array, 1)) {exit(1)}
        return average(ave_array)
    }

    // End pedantry

    function median(MedianArray=[]) {
        if (!checkfunctype("median", "array", MedianArray)) {exit(1)}
        NewArray=float(MedianArray)
        MedianArray=copy(NewArray)
        MedianArray=sort(MedianArray)
        Len=len(MedianArray)
        Calc=divmod(Len, 2)
        Pos=Calc[0]
        Remainder=Calc[1]
        if (Remainder == 1) {
            Median=MedianArray[Pos]
        } else {
            Median=(float(MedianArray[Pos]) + float(MedianArray[Pos-1]))/2.0
        }
        return Median
    }
    
    function harmonicmean(MyArray) {
        if (!checkfunctype("harmonicmean", "array", MyArray)) {exit(1)}
        Obs=len(MyArray)
        Counter=0
        foreach n in MyArray {
            Counter += (1/float(n))
        }
        return Obs / Counter
    }

    function array.mode() {
        return mode(self)
    }

    function array.average() {
        return average(self)
    }

    function array.mean() {
        return mean(self)
    }

    function array.median() {
        return median(self)
    }

    function array.harmonicmean() {
        return harmonicmean(self)
    }
}

