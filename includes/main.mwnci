if (!INCLUDE["FILE"]) {include("file")}
if (!INCLUDE["METHODS"]) {include("methods")}


/*
 Define some handy constants
*/
const OS=getos()
const ARGV=args()
const ARGC=len(ARGV)
const PID=getpid()
const NULL=chr(0)
const PROGNAME = (ARGC > 0) ? basename(ARGV[0]) : ""

/*
 File-objects for STDIN, STDOUT, and STDERR.

 Rather than opening these by name/path we have magic-strings which
 are recognized by our "open" primitive.
*/
const STDIN= open("!STDIN!")
const STDOUT=open("!STDOUT!")
const STDERR=open("!STDERR!")

if (!INCLUDE["MAIN"]) {
    INCLUDE=set(INCLUDE, "MAIN", true)

//
// Argument checker for all functions
//
    function checkfunctype(func, expected, received, argnum=1) {
        ReceivedType=type(received)
	    if (expected == "number") {
            if (ReceivedType == "integer" || ReceivedType == "float") {
	        return true
	    } else {
	        println("Error calling `",func,"`: ERROR: TypeError: ", func, "() expected argument #", argnum, " to be `INTEGER` or `FLOAT`, got `", toupper(ReceivedType), "`")
                return false
	        }
	    }
        if (expected == "iterable") {
            if (ReceivedType == "string" || ReceivedType == "array") {
                return true
            } else {
                println("Error calling `",func,"`: ERROR: TypeError: ", func, "() expected argument #", argnum, " to be `STRING` or `ARRAY`, got `", toupper(ReceivedType), "`")
                return false
            }
        }
        if (expected == "collection") {
            if (ReceivedType == "hash" || ReceivedType == "array") {
                return true
            } else {
                println("Error calling `",func,"`: ERROR: TypeError: ", func, "() expected argument #", argnum, " to be `HASH` or `ARRAY`, got `", toupper(ReceivedType), "`")
                return false
            }
        }
        if (ReceivedType != expected) {
            println("Error calling `",func,"`: ERROR: TypeError: ", func, "() expected argument #", argnum, " to be `",
            toupper(expected), "` got `", toupper(ReceivedType), "`")
            return false
        }
        return true
    }

// Rest() moved to here because buitlin shift() has replaced it 
    function rest(Array) {
        if (!checkfunctype("rest", "array", Array, 1)) {exit(1)}
        return shift(Array)
    }
    
// Binary to Decimal
    function bin2dec(BinaryNumber=NULL) {
        if (BinaryNumber == NULL) {return false}
        BinaryNumber=trimprefix(string(BinaryNumber), "0b")
        if (!match("^[0-1]{1,}$", BinaryNumber)) {
            println("Error calling `bin2dec`: ERROR: TypeError: bin2dec() expected argument #1 to be BINARY, got ", BinaryNumber)
            return false
        }
        Len=len(BinaryNumber)-1
        Result=0
        foreach n in 0..Len {
            Result = Result*2 + int(BinaryNumber[n])
        }
        return Result
    }

    function cls() {
        Clear=system("clear")
        print(Clear)
	    return true
    }
    
    function contains(Line="", Search="") {
        if (index(Line, Search) != -1) {return true}
        return false
    }

    function getblock(StartBlock, EndBlock, ArrayName) {
        if (!checkfunctype("getblock", "string", StartBlock, 1)) {exit(1)}
        if (!checkfunctype("getblock", "string", EndBlock, 2)) {exit(1)}
        if (!checkfunctype("getblock", "array", ArrayName, 3)) {exit(1)}
        FoundLine=[]
        InBlock=false
        foreach Line in ArrayName {
            if (match(StartBlock, Line)) {
                InBlock=true
            } else {
                if (match(EndBlock, Line)) {
                    FoundLine=push(FoundLine, Line)
                    InBlock=false
                }
            }
            if (InBlock) {
                FoundLine=push(FoundLine, Line)
            }
        }
        return FoundLine
    }

    function getfileblock(StartBlock, EndBlock, FileName) {
        if (!checkfunctype("getfileblock", "string", StartBlock, 1)) {exit(1)}
        if (!checkfunctype("getfileblock", "string", EndBlock, 2)) {exit(1)}
        if (!checkfunctype("getfileblock", "string", FileName, 3)) {exit(1)}
        if (!file(FileName)) {
            println("Can't open ", FileName)
            return false
        }
        FileOutput=split(cat(FileName), "\n")
        getblock(StartBlock, EndBlock, FileOutput)
    }

    function head(Data, Lines=0) {
        if (!checkfunctype("head", "iterable", Data, 1)) {exit(1)}
        if (!checkfunctype("head", "integer", Lines, 2)) {exit(1)}
        IsString=false
        if (type(Data) == "string") {
            Data=split(Data, "\n")
            IsString=true
        }
        tdata=[]
        if (Lines == 0) {Lines = 10}
        Length=len(Data)
        if (Lines >= Length) {
            if (IsString) {
                return(join(Data, "\n"))
            }
            return Data
        }
        Count=0
        while (Count < Lines) {
            tdata=push(tdata, Data[Count])
            Count++
        }
        if (IsString) {
            return(join(tdata, "\n"))
        }
        return tdata
    }

    function interpol(data={}, text="") {
        if (!checkfunctype("interpol", "hash", data, 1)) {exit(1)}
        if (!checkfunctype("interpol", "string", text, 2)) {exit(1)}
        foreach key in keys(data) {
            rstring="${"+key+"}"
            text=replaceall(text, rstring, string(data[key]))
        }
        return text
    }

    function intersect(array_a, array_b) {
        if (!checkfunctype("intersect", "array", array_a, 1)) {exit(1)}
        if (!checkfunctype("intersect", "array", array_b, 2)) {exit(1)}
        InterArray=[]
        array_a=uniq(array_a)
        array_b=uniq(array_b)
        foreach Value in array_a {
            found=contains(array_b, Value)
            if (found) {
    	        InterArray=push(InterArray, Value)
    	    }
        }
        return InterArray
    }

    function isrsorted(SortedArray) {
        if (!checkfunctype("isrsorted", "array", SortedArray, 1)) {exit(1)}
        return issorted(reverse(SortedArray))
    }

    function lines(data) {
        if (type(data) == "string") {
            return len(split(data, "\n"))
        }
        if (type(data) == "array") {
            return len(data)
        }
        println("Error calling `lines`: ERROR: TypeError lines() expected argument #1 to be `STRING` or `ARRAY`, got `", toupper(type(data)), "`")
        exit(1)
    }

    function map(marray,fnc) {
       result = []
       foreach item in marray {
          result=push(result,fnc(item))
       }
       return result
    }

    function max(MyArray=[]) {
        if (!checkfunctype("max", "array", MyArray, 1)) {exit(1)}
        ArrayLen=len(MyArray)
        return (ArrayLen == 0) ? 0 : MyArray.sort()[ArrayLen -1]
    }

    function min(MyArray=[]) {
        if (!checkfunctype("min", "array", MyArray, 1)) {exit(1)}
        return (len(MyArray) == 0) ? 0 : MyArray.sort()[0]
    }

    function procexists(pid=-1) {
        if (!checkfunctype("procexists", "integer", pid, 1)) {exit(1)}
        Procs=split(trim(system("ps aux")), "\n")
        Procs=tail(Procs, len(Procs)-1)
        foreach Proc in Procs {
            Pid=int(fields(Proc)[1])
            if (Pid == pid) {
                return true
            }
        }
        return false
    }

    function rotl(Array, Amount=0) {
        if (!checkfunctype("rotl", "iterable", Array, 1)) {exit(1)}
        if (!checkfunctype("rotl", "integer", Amount, 2)) {exit(1)}
	    if (Amount < 1) {Amount=1}
        VarType=type(Array)
        Valid=false
        isString=false
        if (VarType == "string") {
            Array=split(Array, "")
            isString=true
            Valid=true
        }
        if (VarType == "array") {
            Valid=true
        }
        if (!Valid) {
            println("Error calling `rotl`: ERROR: argument to rotl() not supported, expected STRING or ARRAY, got ", toupper(type(Array)))
            exit(1)
        }
        foreach n in 1..Amount {
            ToMove=Array[0]
            Array=delete(Array,0)
            Array=push(Array, ToMove)
        }
        if (isString) {
            Array=join(Array, "")
        }
        return Array
    }

    function rotr(Array, Amount=0) {
        if (!checkfunctype("rotr", "iterable", Array, 1)) {exit(1)}
        if (!checkfunctype("rotr", "integer", Amount, 2)) {exit(1)}
        if (Amount < 1) {Amount=1}
        VarType=type(Array)
        Valid=false
        isString=false
        if (VarType == "string") {
            Array=split(Array, "")
            isString=true
            Valid=true
        }
        if (VarType == "array") {
            Valid=true
        }
        if (!Valid) {
            println("Error calling `rotr`: ERROR: argument to rotr() not supported, expected STRING or ARRAY, got ", toupper(type(Array)))
            exit(1)
        }
        foreach n in 1..Amount {
            ToMove=pop(Array)
            Array=insert(Array, 0, ToMove)
        }
        if (isString) {
            Array=join(Array, "")
        }
        return Array
    }


    function rsort(arr) {
        return reverse(sort(arr))
    }

    function sec2time(seconds=0) {
        if (!checkfunctype("sec2time", "integer", seconds, 1)) {exit(1)}
        elapse={"Day": seconds/60/60/24,
                "Hour": (seconds/60/60)%24,
                "Min": (seconds/60)%60,
                "Sec": seconds%60}
        return elapse
    }
 
    function tail(data, Lines=0) {
        if (!checkfunctype("tail", "iterable", data, 1)) {exit(1)}
        if (!checkfunctype("tail", "integer", Lines, 2)) {exit(1)}
        IsString=false
        if (type(data) == "string") {
            data=split(data, "\n")
    	    IsString=true
        }
        tdata=[]
        if (Lines == 0) {Lines = 10}
        l=len(data)
        if (Lines >= l) {
            if (IsString) {
                return(join(data, "\n"))
            }
            return data
        }
        Count=l-Lines
        while (Count < l) {
            tdata=push(tdata, data[Count])
            Count++
        }
        if (IsString) {
            return(join(tdata, "\n"))
        }
        return tdata
    }

    function unzip(MyArray=[]) {
        if (len(MyArray) == 0) {
            return MyArray
    	}
    	ZipArray=[]
    	DataLen=len(MyArray[0])
    	foreach Blank in 1..DataLen {
            ZipArray=ZipArray.push([])
    	}
    	foreach Block in MyArray {
            foreach Index, Entry in Block {
	        Temp=ZipArray[Index]
	        Temp=Temp.push(Entry)
	        ZipArray=ZipArray.set(Index, Temp)
            }
        }
        return ZipArray
    }

    function usort(MyArray) {
        return sort(uniq(MyArray))
    }

    function lookupcname(Search="") {return nslookup(Search, "cname")}
    function lookuphost(Search="") {return nslookup(Search, "host")}
    function lookupip(Search="") {return nslookup(Search, "ip")}
    function lookuptxt(Search="") {return nslookup(Search, "txt")}
    function lookupptr(Search="") {return nslookup(Search, "ptr")}
    function lookupns(Search="") {return nslookup(Search, "ns")}
    function lookupmx(Search="") {return nslookup(Search, "mx")}
    
    function permsym(BPerms="") {
        DefPerms=["-", "-", "-"]
        if (BPerms[0] == "1") {DefPerms=set(DefPerms, 0, "r")}
        if (BPerms[1] == "1") {DefPerms=set(DefPerms, 1, "w")}
        if (BPerms[2] == "1") {DefPerms=set(DefPerms, 2, "x")}
        return join(DefPerms, "")
    }

    function oct2sym(Perms="") {
        Binary=trimprefix(oct2bin(Perms), "0b")
        while (len(Binary) < 12) {
            Binary="0" + Binary
        }
        Spec=substr(Binary,0,3)
        User=substr(Binary,3,3)
        Group=substr(Binary,6,3)
        Other=substr(Binary,9,3)

        SymUser=permsym(User)
        SymGroup=permsym(Group)
        SymOther=permsym(Other)

        FullPerms=split(SymUser + SymGroup + SymOther, "")
        BSpec=split(Spec, "")

// Sticky
        if (BSpec[2] == "1") {
            if (FullPerms[8] != "x") {
                FullPerms=set(FullPerms, 8, "T")
            } else {
                FullPerms=set(FullPerms, 8, "t")
            }
        }

// Setgid
        if (BSpec[1] == "1") {
            if (FullPerms[5] != "x") {
                FullPerms=set(FullPerms, 5, "S")
            } else {
                FullPerms=set(FullPerms, 5, "s")
            }
        }

// Setuid
        if (BSpec[0] == "1") {
            if (FullPerms[2] != "x") {
                FullPerms=set(FullPerms, 2, "S")
            } else {
                FullPerms=set(FullPerms, 2, "s")
            }
        }
        FullPerms=join(FullPerms, "")
        return FullPerms
    }

    function values(Data={}) {
        if (!checkfunctype("values", "hash", Data, 1)) {exit(1)}
        MyArray=[]
        foreach Value, _ in Data {
            MyArray=push(MyArray, Value)
        }
        return MyArray
    }

    function items(Data={}) {
        if (!checkfunctype("items", "hash", Data, 1)) {exit(1)}
        MyArray=[]
        foreach Value, Key in Data {
            MyArray=MyArray.push([Key, Value])
        }
        return MyArray
    }

    function rsortips(IPArray=[]) {
        if (!checkfunctype("rsortips", "array", IPArray, 1)) {exit(1)}
	    if (len(IPArray) <= 1) {return IPArray}
	    return reverse(sortips(IPArray))
    }

    function oct2bin(o_number) {
        return bin(oct2dec(o_number))
    }

    function oct2dec(OctNumber) {
        Number=reverse(string(OctNumber))
        Counter=0
        foreach i, x in Number {
            Counter += int(x) * (8 ** i)
        }
	    return Counter
    }

    function enumerate(MyArray=[], Counter=0) {
        if (!checkfunctype("enumerate", "array", MyArray, 1)) {exit(1)}
        if (!checkfunctype("enumerate", "integer", Counter, 2)) {exit(1)}
        MyHash={}
        foreach Index, Value in MyArray {
    	    MyHash=MyHash.set(Index + Counter, Value)
        }
        return MyHash
    }

    function fromkeys(MyArray=[], Value=0) {
        if (!checkfunctype("fromkeys", "array", MyArray, 1)) {exit(1)}
        MyHash={}
        foreach Entry in MyArray {
            MyHash=MyHash.set(Entry, Value)
        }
        return MyHash
    }
    
    function rindex(Haystack, Needle) {
        Pos=-1
        switch (type(Haystack)) {
	        case "array" {
	            HayLen=len(Haystack)-1
	            Haystack=reverse(Haystack)
	            Pos=index(Haystack, Needle)
	            if (Pos != -1) {
	                Pos=HayLen-Pos
	            }
	        }
	        case "string" {
	            HayLen=len(Haystack)
	            Nsearch=reverse(Needle)
		        Nstack=reverse(Haystack)
		        Pos=index(Nstack, Nsearch)
		        if (Pos != -1) {
		            Pos=HayLen - len(Nsearch) - Pos
		        }
	        }
	        default {
	            println("Error calling `rindex`: ERROR: TypeError: rindex() expected argument #1 to be `STRING` or `ARRAY`, got `", toupper(type(Haystack)), "`")
	            exit(1)
	        }
	    }
	    return Pos
    }
}
